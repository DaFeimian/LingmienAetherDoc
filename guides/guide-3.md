---
title: 异步和多线程
order: 3
group:
  title: 开发指南
  order: 3
---
[菜鸟教程](https://www.runoob.com/python/python-multithreading.html)

> - 并发：有一群人在挖坑。可能是挖同一个坑，也可能是各自挖各自的坑。
- 单线程 vs. 多线程：一个人在挖坑 vs. 一群人在挖坑。坑的数量不明，人员的组成不明，挖坑的具体安排不明。
- 同步：可以是下面中的某一个：
- 线程同步：一群人在挖坑，同时有一群人在拉土，坑挖好了的时候拉土的人才开始工作。
- 数据同步：一群人在挖坑，以某种方式保证所有人都知道挖坑进度，防止挖到别人的坑里并产生事故。
- 异步：一个或一群人在挖坑，忽然有人指示开挖新坑，但并没有人为之所动；几小时后连新坑都挖完了，但具体中间是怎么安排的并没有人知道。

### 那我让一个 tick 分散到多个线程上去不就可以了？
真的可以吗？

让我们回到挖坑这件事上来。一个人挖坑，的确不会快到哪里去。但两个人挖坑就一定比一个人快吗？也许你会发现只有一把铲子可以用。好一点的情况可以是有三把铲子可以用，但请注意这是资源浪费，因为一个人不太可能同时挥舞两把铲子。即便是有不多不少两把铲子，你还可能会遇到因不合理的挖坑分工导致的工伤事故，于是挖坑计划就会被推迟，你也许会因此付出更多的资源。

让我们再把问题扩大化：现在我们要找一万人挖一个天坑。有鉴于要挖的是一个天坑，你大概不会直接让一万人上铲子蛮干，而是让这一万人中的一部分会操纵挖掘机的人来操作挖掘机挖坑，剩下的人则是负责挖掘机干不了的细活以及后勤工作等等。但请注意，你挖的不是隧道，是坑，你不能把这帮人分成两队，一队从上面开始挖，一队从下面开始挖，这样只会让上面的人和挖掘机忽然掉下来，并把下面的人和挖掘机砸成板。分成三队自然更不靠谱，理由同分成两队。退一步讲，你该怎么让一帮人从下面往上开始挖坑？如果你要先钻到下面去，你不是已经先钻出一个坑来了？

所以最靠谱方案的还是从上面一起往下挖。那么能不能分成两队，一队挖左半边一队挖右半边呢？听上去可以，但请考虑一下，两队工作效率还有可能不对等，结果挖着挖着，忽然坑塌了，于是又是新的事故出现了。

所以结论是，挖坑不能像挖隧道那样分成两队分别行动，约定在某地点打通并胜利会师。

回到 Minecraft 上来。刚才的坑就是 Minecraft 的一个游戏刻（Gametick，部分 CBer 使用缩写 gt），挖坑的过程大抵就是方块、实体、TileEntity 刷新的过程。所有的刷新操作都会对周围的方块造成影响，反映到区块上，就是对区块数据的写操作，比如方块破坏、亮度更新、方块状态变更等等。两种实体（Entity 和 TileEntity）的刷新还通常会改变自身及周围方块及实体的状态。试想，一个 TileEntity 的刷新操作不在服务器线程上完成，然后它对周围的方块进行了修改，但一部分被修改的方块也不幸被选中进行刷新，此时就会出现数据竞争的情况——两个线程同时修改一个对象里的数据。此时有三个选择：
加锁。基本是套一个 synchronized 临界区域这样的东西，但加锁释锁也有开销，更何况你可能面对的是成百上千个 TileEntity 同时加锁，然后若干线程在等这些锁被释放。

免锁逻辑。对于 TileEntity 和普通实体来说这个可能好办一些，但对于采用了享元设计的方块来说... 免锁逻辑真的能实现吗？TileEntity 修改区块数据时打算怎么办？

放弃多线程，致力于优化游戏本身的性能瓶颈。

### 线程不安全
如前文所述，因为数据竞争，所以 Minecraft 是一个线程不安全的游戏。你在别的线程上修改数据，也许会造成毁灭性的后果。
``` java
// 这个方法会在网络通信线程上执行，而非游戏主线程。
public void processPacketData(CustomPacketFromClient packet) {
    removeSomeTileEntities();
}

// 同时，有一个 TileEntity 还在更新...
pubilc void update() {
    if (!world.isRemote) {
        addSomeNewTileEntities();
    }
}
```
这样也就只能等待 GG 了。你当然也可以说换成线程安全的容器，但如果你不是要把一个游戏刻分散到多个线程上去的话，线程安全的容器只是多此一举，除了徒增烦恼，并不能带来实质性的改变。

### 异步
正因为 Minecraft 的主要逻辑都集中在服务器线程上，所以下面的代码是错误的：
``` java
// 错误示范，请勿模仿！
@SubscribeEvent
public void onTick(WorldTickEvent.Pre event) {
    Thread.sleep(10000L); // 延时 10 秒后执行逻辑
    doLogic();
}
```
因为只有一个线程在执行游戏逻辑，Thread.sleep(10000L) 会使得整个游戏暂停十秒钟（一万毫秒），很容易令客户端与服务器失去连接，进而造成诸如“单机游戏时提示连接超时然后退回服务器选择界面”这样的诡异情况。很不幸，的确有新手会犯这样的错误。

正确的解决思路有两种：

1. 依赖游戏刻，而非现实世界中的时间。
``` java
  // 本段代码以 Forge 为框架
  private int counter = 0;
  @SubscribeEvent
  public void onTick(TickEvent.WorldTickEvent event) {
      if (counter++ > 200) { // 理想状态下，TPS 为 20，
                             // 此时 10 秒内会执行不多不少 200 个游戏刻。
          doLogic();
          counter = 0; // 重置计数器。
      }
  }
```

2. 如果是 Bukkit 或者 Sponge 这样的框架，其提供的异步操作 API 是允许指定延迟时间的。
``` java
  // 本段代码以 Sponge 为框架
  Sponge.getScheduler().createAsyncExecutor(myPluginObject)
        .schedule((Runnable) () -> doLogic(), 10, TimeUnit.SECONDS);
```
事情就这样结束了吗？并没有。

还有这样的情况：某种强力的斧子一砍就是一整棵树，但这棵树特别特别高，于是一整个游戏刻全都在全力追上砍树的进程了。怎么办？

多线程在这个时候似乎符合直觉了：因为`Minecraft`特殊的物理系统，我完全可以让树分好几段“掉”下来。但请注意，这里还是有数据同步的问题——不仅是木头会掉下来，树叶也会在失去与木头的连接后开始凋谢检查，所以正常的并发根本行不通。

Minecraft 自身有一个简单的异步执行操作的机制，addScheduledTask(Runnable task)（MCP func_152344_a），这个方法来自 IThreadListener 接口，所以你可以在客户端独有的 Minecraft 或者客户端和服务器都有的 MinecraftServer 两个类中找到这个方法。所有通过此方法规划的任务都会在未来的某一个游戏刻时执行。大约是下面这个逻辑（伪（C）代（+）码（+））：
``` java
void gameLoop() {
    while (keepGameRunning) {
        // Do other logic
        for (int i = 0; i < 20; i++) {
            // Do other logic
            auto task = this->scheduledTaskQueue.front();
            this->scheduledTaskQueue.pop();
            task.run();
            // Do other logic
        }
        // Do other logic
    }
}
```
如果你需要让你的逻辑分散在多个游戏刻上，用这个 addScheduledTask 就可以。这样做大约相当于，让一个人每天挖一点坑，过个几百天就能挖出大坑。

`addScheduledTask`还有一个用途是让一部分代码在主线程上工作，比如刚刚接收到的数据包，解析完数据，要执行逻辑时，需要这么做。

### 多线程的正确用法
但实际上，使用多线程有时候的确是合理的。比如 Mod 检查更新的时候。
``` java
public void versionCheck() {
    try {
        URL url = new URL("...");
        InputStream remoteData = url.openStream();
        List<String> lines = readAllLines(remoteData);
    } catch (Exception e) {
        logError(e);
    }
}
```
请注意，这个 IO 操作会阻塞线程。换言之，如果网络不好，这个东西就会卡住无法继续执行，直到超时。此时多线程就是一个合理的解决方案。
``` java
new Thread(VersionCheck::versionCheck, "VersionCheck").start();
```


## 什么是异步编程
首先来看一下异步模型。在异步模型中，允许同一时间发生（处理）多个事件。程序调用一个耗时较长的功能（方法）时，它并不会阻塞程序的执行流程，程序会继续往下执行。当功能执行完毕时，程序能够获得执行完毕的消息或能够访问到执行的结果（如果有返回值或需要返回值时）。

下面通过一个示例来看一下同步和异步的区别。示例中程序通过网络获取两个文件，并对两个文件进行合并处理：

![](/uploads/da-fei-mian/images/m_89718e82dc4593f58a6c7d185b686b79_r.png)

上述示例，在异步系统当中的解决方案是开启一个额外的线程进行处理。第一个线程获取第一个文件，第二个线程获取第二个文件，第二个线程并不需要等待第一个线程执行完毕再执行。当两个线程都获得到对应的结果之后，再重新同步处理合并结果的操作。

再来看另外一个场景。单线程方法读取OS（操作系统）当中的文件并需要进行数学运算。而在异步系统中，程序发起读取OS中文件的请求，由于读取操作比较耗时，在等待读取文件时，程序会将控制器返回给CPU进行数学运算。

在异步编程中，通常会针对比较耗时的功能提供一个函数，函数的参数中包含一个额外的参数，用于回调。而这个函数往往称作回调函数。当比较耗时的功能执行完毕时，通过回调函数将结果返回。关于回调函数相关的知识可参考文章《两个经典例子让你彻底理解java回调机制》。

## 什么是多线程编程
多线程是指同时并发或并行执行多个指令（线程）。

在单核处理器上，多线程往往会给人程序是在并行执行的错觉。实际上，处理器是通过调度算法在多线程之间进行切换和调度。或者根据外部输入（中断）和线程的优先级的组合来进行线程的切换。

在多核处理器上，线程才是真正的并行运行。多个处理器同时执行多个线程，以达到更加高效的处理。

一个简单的示例就是：开启两个浏览器窗口同时下载两个文件。每个窗口都使用一个新的线程去下载文件，它们之间并不需要谁等待谁完成，而是并行进行下载。

下图展示了并发执行多线程应用程序的流程：

![](/uploads/da-fei-mian/images/m_34510d366ca51dc535b9cdc32353d915_r.png)

## 异步与多线程的区别
通过上面的介绍，我们可以看出多线程都是关于功能的并发执行。而异步编程是关于函数之间的非阻塞执行，我们可以将异步应用于单线程或多线程当中。

因此，多线程只是异步编程的一种实现形式。

比如，你和你的朋友决定一起做一顿午餐。“异步”就是你对朋友说：“你去商店买意大利面，回来的时候告诉我一声，然后一起做午餐。在你买意大利面的同时，我去准备番茄酱和饮料。”

而“线程”是：“你烧水，我加热番茄酱。当水烧开了，告诉我，我把意大利放进去。当番茄酱热了，你可以把奶酪添加进去。当两者都完成了，就可以坐下来一起吃晚餐。”在线程的示例中，我们可以看到“When，Do”的事件顺序，而这些顺序代表着每个人（线程）的指令集集合的顺序。

上述示例可以看出，多线程是与具体的执行者相关的，而异步是与任务相关的。

多线程是程序设计的逻辑层概念，它是进程中并发运行的一段代码，可以实现线程间的切换执行。

异步和同步是相对的，异步就是彼此独立，在等待某事件的过程中继续做自己的事，不需要等待这一事件完成后再工作。

多线程就是实现异步的一个方式。异步是让调用方法的主线程不需要同步等待另一线程的完成，从而可以让主线程干其它的事情。

所以本质上，异步和多线程并不是一个同等关系，异步是最终目的，多线程只是实现异步的一种手段。

## 如何选择
面对多线程和异步，我们该如何选择呢？其实，通常情况下选择的依据是主要取决于性能。

那么，同步/异步与单线程/多线程之间的所有组合，哪种模型表现更好？

简而言之，对于具有大量I/O操作和不同计算的大规模应用程序，使用异步多线程有利于充分利用计算资源，并且能够照顾到非阻塞函数。这也是所有操作系统所采用的线程模型。

编写异步操作的复杂程度较高，程序主要使用回调方式进行处理，与正常的思维方式有些出入，而且难以调试。而多线程的使用（滥用）会给系统带来上下文切换的额外负担，并且线程间的共享变量可能造成死锁。

因此在实现这两种模式时，往往需要处理资源竞争、死锁、共享资源和回调事件等问题。
`input_panel`与`panel`类似，可以用来放置其他控件，但除此之外还可以用来拖动，或实现“模态框”功能。

```json
"InputPanel" : {
      "anchor_from" : "top_left",
      "anchor_to" : "top_left",
      "button_mappings": [
         {
           "from_button_id": "button.menu_select",
           "to_button_id": "#netease_to_button_id",
           "mapping_type": "pressed"
         }
      ],
      "layer" : 10,
      "modal" : true,
      "is_swallow": true,
      "contained": true,
      "draggable": "both",
      "offset" : [ 0.0, 0.0 ],
      "size" : [ 198.0, 137.0 ],
      "type" : "input_panel",
      "visible" : true
}
```

|变量|默认值|解释|
|:-:|:-:|:-:|
|modal|false|设为true时，该InputPanel视为模态框，见注2|
|is_swallow|false|设为true时，该InputPanel的输入会吞噬事件，见注3|
|draggable|not_draggable|当前控件可拖拽方式，默认为not_draggable不可拖拽，"horizontal"代表水平拖拽，"vertical"代表垂直拖拽，"both"代表自由拖拽|
|contained|false|该控件可拖动时，是否会被父控件的大小范围所限制，默认值为false，见注4|
|button_mappings|[]|该值为开启拖拽功能所必须的属性，可以理解成开启接受屏幕点击事件|

### 注1
```
该控件的拖动功能也遵循UI控件的碰撞规则，当InputPanel中有按钮、滚动列表等接受鼠标事件的控件时，点击在这些控件并不会触发InputPanel的拖动操作。
```
### 注2
```
“模态框”是指将用户的UI点击操作限制在这个控件及其子控件，而其他的控件都不会响应用户操作。

如果界面上同时存在多个模态框，其中层级最高的生效。

可以用来处理ScrollView控件上显示其他控件时，点击会穿透到ScrollView的问题，可参考UIDemo示例的“InputPanel演示”

界面编辑器暂不支持，可先用Panel搭建后手动在json中修改属性。
```

### 注3
```
吞噬事件是指点击该面板时，点击事件不会穿透到世界。如破坏方块、镜头转向不会被响应。
```

### 注4
```
InputPanel维护着一个拖拽偏移量，它代表着在整个拖拽过程中，InputPanel相对于控件出生点坐标的偏移量，**与控件自身的offset无关**。举个例子，InputPanel经过了5次手动拖拽后位置向右移动了5像素，则拖拽偏移量的值为(5, 0)。

当contained为true时，拖拽偏移量存在限制，最小不能超过(0,0)，最大不能超过父控件的大小减去InputPanel控件的大小。

这也就意味着无论InputPanel是否设置了offset，由于初始拖拽偏移量为(0,0), 使控件无法负方向移动，因此需要将InputPanel放置在其父控件的左上角，或调用SetOffsetDelta接口手动设置拖拽偏移量。
```